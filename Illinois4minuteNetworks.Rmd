---
title: "Illinois Spatsoc 2"
output: html_notebook
---

On daytime data only.

## Group B

```{r}
#convert to data table
library(data.table)
GroupB.day.dt = setDT(GroupB.day.df)

library(spatsoc)

# Temporal Groups (grouping times)
group_times(GroupB.day.dt, datetime = 'Time', threshold = '4 minutes') #temporal threshold - the finer the better

# Spatial groups using 'timegroup' generated by group_times
#group_pts(GroupB.day.dt, threshold = 4, id = 'idnum', coords = c('X', 'Y'), timegroup = 'timegroup') 
#threshold = 50 ==  50m in UTM.
# decided spatial threshold = 4m
```
*groups_pts uses the chain rule - i.e. if A is within threshold of B, and B is within threshold of C, A B and C are all defined as being in the same group.* This is not applicable here?

*edge_dist* calculates the geographic distance between animal telemetry relocations within each time group and returns all paired relocations within the spatial threshold (Figure 5). edge_dist uses a distance matrix like group_pts, but, in contrast, does not use the chain rule to group relocations. Instead, it returns an edge list of each individual and all others within the spatial distance threshold.
```{r}
edgesB <- edge_dist(GroupB.day.dt, threshold = 4, id = 'idnum', coords = c('X', 'Y'), timegroup = 'timegroup')
```

A group-by-individual (gbi) matrix forms columns of individuals and rows of groups, boolean indicates membership.

Create a matrix of the frequency that each cow was within the threshold distance of an other:
```{r}
library(combinat)

GroupB.pairs = combn(groupB.ids, 2)

timegroupsB = unique(GroupB.day.dt$timegroup)
```

```{r}
# matrix to store count of 'interactions' for each pair
countB.mat <- matrix(0, ncol = 8, nrow=8, dimnames = list(groupB.ids, groupB.ids))

# matrix to store count of 'interactions' for each pair
freqB.mat <- matrix(0, ncol = 8, nrow=8, dimnames = list(groupB.ids, groupB.ids))

#matrix to store number of timepoints at which there is gps data recorded for both cows in each pair
obsB.mat <- matrix(0, ncol = 8, nrow=8, dimnames = list(groupB.ids, groupB.ids))

for(i in 1:28){
  pair.id1 = GroupB.pairs[1, i]
  pair.id2 = GroupB.pairs[2, i]
  
  for(j in 1:length(timegroupsB)){
    sub1 = edgesB[which(edgesB$timegroup == j), ]
    sub2 = sub1[which(sub1$ID1 == pair.id1), ]
    sub3 = sub2[which(sub2$ID2 == pair.id2), ]
    sub4 = sub1[which(sub1$ID1 == pair.id2), ]
    if(nrow(sub3 != 0)){ #i.e. if there is an edge between the pair at the timepoint in the edge list
      countB.mat[pair.id1, pair.id2] = countB.mat[pair.id1, pair.id2] + 1
      countB.mat[pair.id2, pair.id1] = countB.mat[pair.id2, pair.id1] + 1
    }
    if(nrow(sub2) != 0 & nrow(sub4) != 0){ #i.e. if there is data for both cows at this timepoint
      obsB.mat[pair.id1, pair.id2] = obsB.mat[pair.id1, pair.id2] + 1
      obsB.mat[pair.id2, pair.id1] = obsB.mat[pair.id2, pair.id1] + 1
    }
  }
  freqB.mat[pair.id1, pair.id2] = countB.mat[pair.id1, pair.id2]/obsB.mat[pair.id1, pair.id2]
  freqB.mat[pair.id2,pair.id1] = countB.mat[pair.id2,pair.id1]/obsB.mat[pair.id2,pair.id1]
}

countB.mat
freqB.mat
```

```{r}
heatmap(freqB.mat,  Rowv = NA, Colv = NA, symm = T, main = 'Frequency of Interactions - Group B')

library(pheatmap)
breaklistB = seq(0, 0.23, by = 0.0115)

pheatmap(freqB.mat, color = colorRampPalette(c('white','yellow', 'red', 'black'))(20), breaks = breaklistB, cluster_cols = F, cluster_rows = F, treeheight_col = 0, cellwidth= 33, cellheight = 33, treeheight_row = 0, main = 'Frequency of 4 Minute Interactions - Group B All Days')
```

```{r}
library(igraph)

GroupB.graph <- graph.adjacency(freqB.mat, mode="undirected", weighted=TRUE)
# E(GroupB.graph)$weight is the count from the original matrix

#normalize
E(GroupB.graph)$weight <- (E(GroupB.graph)$weight - min(freqB.mat))/(max(freqB.mat)- min(freqB.mat))

#Color scaling function
c_scale <- colorRamp(c('white','black'))

#Applying the color scale to edge weights.
#rgb method is to convert colors to a character vector.
E(GroupB.graph)$color = apply(c_scale(E(GroupB.graph)$weight), 1, function(x) rgb(x[1]/255,x[2]/255,x[3]/255) )

E(GroupB.graph)$weight <- (E(GroupB.graph)$weight)*10

plot(GroupB.graph, edge.width = E(GroupB.graph)$weight, edge.col = E(GroupB.graph)$color, layout=layout.fruchterman.reingold, main = 'Network of Interaction Frequency - Group B')
```

## Group A

```{r}
#convert to data table
library(data.table)
GroupA.day.dt = setDT(GroupA.day.df)

library(spatsoc)

# Temporal Groups (grouping times)
group_times(GroupA.day.dt, datetime = 'time', threshold = '4 minutes') #temporal threshold - the finer the better

# Spatial groups using 'timegroup' generated by group_times
#group_pts(GroupA.day.dt, threshold = 4, id = 'idnum', coords = c('X', 'Y'), timegroup = 'timegroup') 
#threshold = 50 ==  50m in UTM.
# decided spatial threshold = 4m
```

```{r}
edgesA <- edge_dist(GroupA.day.dt, threshold = 4, id = 'idnum', coords = c('X', 'Y'), timegroup = 'timegroup')
```

Create a matrix of the frequency that each cow was within the threshold distance of an other:
```{r}
library(combinat)

GroupA.pairs = combn(groupA.ids, 2)

timegroupsA = unique(GroupA.day.dt$timegroup)
```

```{r}
# matrix to store count of 'interactions' for each pair
countA.mat <- matrix(0, ncol = 24, nrow=24, dimnames = list(groupA.ids, groupA.ids))

# matrix to store count of 'interactions' for each pair
freqA.mat <- matrix(0, ncol = 24, nrow=24, dimnames = list(groupA.ids, groupA.ids))

#matrix to store number of timepoints at which there is gps data recorded for both cows in each pair
obsA.mat <- matrix(0, ncol = 24, nrow=24, dimnames = list(groupA.ids, groupA.ids))

for(i in 1:276){
  pair.id1 = GroupA.pairs[1, i]
  pair.id2 = GroupA.pairs[2, i]
  
  for(j in 1:length(timegroupsA)){
    sub1 = edgesA[which(edgesA$timegroup == j), ]
    sub2 = sub1[which(sub1$ID1 == pair.id1), ]
    sub3 = sub2[which(sub2$ID2 == pair.id2), ]
    sub4 = sub1[which(sub1$ID1 == pair.id2), ]
    if(nrow(sub3 != 0)){
      countA.mat[pair.id1, pair.id2] = countA.mat[pair.id1, pair.id2] + 1
      countA.mat[pair.id2, pair.id1] = countA.mat[pair.id2, pair.id1] + 1
    }
    if(nrow(sub2) != 0 & nrow(sub4) != 0){ #i.e. if there is data for both cows at this timepoint
      obsA.mat[pair.id1, pair.id2] = obsA.mat[pair.id1, pair.id2] + 1
      obsA.mat[pair.id2, pair.id1] = obsA.mat[pair.id2, pair.id1] + 1
    }
  }
  freqA.mat[pair.id1, pair.id2] = countA.mat[pair.id1, pair.id2]/obsA.mat[pair.id1, pair.id2]
  freqA.mat[pair.id2, pair.id1] = countA.mat[pair.id2, pair.id1]/obsA.mat[pair.id2, pair.id1]
}

countA.mat
freqA.mat
```

```{r}
heatmap(freqA.mat,  Rowv = NA, Colv = NA, symm = T, main = 'Frequency of Interactions - Group A')

library(pheatmap)

breaklist = seq(0, 0.3, by = 0.015)

pheatmap(freqA.mat, color = colorRampPalette(c('white','yellow', 'red', 'black'))(20), breaks = breaklist, cluster_cols = F, cluster_rows = F, treeheight_col = 0, cellwidth= 11, cellheight = 11, treeheight_row = 0, main = 'Frequency of 4 Minute Interactions - Group A All Days')
```

```{r}
library(igraph)

GroupA.graph <- graph.adjacency(freqA.mat, mode="undirected", weighted=TRUE)

#normalize
E(GroupA.graph)$weight <- (E(GroupA.graph)$weight - min(freqA.mat))/(max(freqA.mat)- min(freqA.mat))

#Color scaling function
c_scale <- colorRamp(c('white','black'))

#Applying the color scale to edge weights.
#rgb method is to convert colors to a character vector.
E(GroupA.graph)$color = apply(c_scale(E(GroupA.graph)$weight), 1, function(x) rgb(x[1]/255,x[2]/255,x[3]/255) )

E(GroupA.graph)$weight <- (E(GroupA.graph)$weight)*10

plot(GroupA.graph, edge.width = E(GroupA.graph)$weight, edge.col = E(GroupA.graph)$color, layout=layout.fruchterman.reingold, main = 'Network of Interaction Frequency - Group A')
```

Replace all values that are less than the mean with 0:
```{r}
freqA.mat2 = freqA.mat
for(i in 1:24){
  for(j in 1:24){
  if(freqA.mat[i,j] < mean(freqA.mat)){
    freqA.mat2[i,j] = 0
  }
  }
}
```

```{r}
GroupA.graph2 <- graph.adjacency(freqA.mat2, mode="undirected", weighted=TRUE)

#normalize
E(GroupA.graph2)$weight <- (E(GroupA.graph2)$weight - min(freqA.mat2))/(max(freqA.mat2)- min(freqA.mat2))

#Color scaling function
c_scale <- colorRamp(c('white','black'))

#Applying the color scale to edge weights.
#rgb method is to convert colors to a character vector.
E(GroupA.graph2)$color = apply(c_scale(E(GroupA.graph2)$weight), 1, function(x) rgb(x[1]/255,x[2]/255,x[3]/255) )

E(GroupA.graph2)$weight <- (E(GroupA.graph2)$weight)*10

plot(GroupA.graph2, edge.width = E(GroupA.graph2)$weight, edge.col = E(GroupA.graph2)$color, layout=layout.fruchterman.reingold, main = 'Network of Interaction Frequency - Group A')
```
Replace all values that are not in top quartile with 0:
#> quantile(freqA.mat)
       0%       25%       50%       75%      100% 
0.0000000 0.1112950 0.1236054 0.1385500 0.1992110
```{r}
freqA.mat3 = freqA.mat
for(i in 1:24){
  for(j in 1:24){
  if(freqA.mat[i,j] < 0.1385500){
    freqA.mat3[i,j] = 0
  }
  }
}
```

```{r}
GroupA.graph3 <- graph.adjacency(freqA.mat3, mode="undirected", weighted=TRUE)

#normalize
E(GroupA.graph3)$weight <- (E(GroupA.graph3)$weight - min(freqA.mat3)/(max(freqA.mat3)- min(freqA.mat3)))

#Color scaling function
c_scale <- colorRamp(c('white','black'))

#Applying the color scale to edge weights.
#rgb method is to convert colors to a character vector.
E(GroupA.graph3)$color = apply(c_scale(E(GroupA.graph3)$weight), 1, function(x) rgb(x[1]/255,x[2]/255,x[3]/255) )

E(GroupA.graph3)$weight <- (E(GroupA.graph3)$weight)*10
V(GroupA.graph3)$size <- (groupA.strength)*5

plot(GroupA.graph3, edge.width = E(GroupA.graph3)$weight, edge.col = E(GroupA.graph3)$color, layout=layout.fruchterman.reingold, main = 'Network of Interaction Frequency - Group A')
```

